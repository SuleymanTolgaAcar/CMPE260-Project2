# CMPE 260 Project 2 - Memory Management Unit in Racket

## Overview

This project simulates a Memory Management Unit (MMU) in Racket (Scheme). MMU is a hardware unit that sits between the CPU and the main memory. It translates the logical (virtual) addresses generated by the CPU to physical addresses.

An address generated by the CPU is known as a logical address, while an address seen by the memory unit is defined as a physical address. The Memory Management Unit (MMU) is responsible for mapping logical addresses to physical addresses. One mechanism for this operation involves the use of registers. The MMU utilizes a relocation register, which holds the smallest physical address, and a limit register, which defines the range of logical addresses. This configuration ensures that each logical address falls within a predefined range and makes accurate and secure address mapping. For example, if the logical address is 256, the value of the limit register is 350 and the value of the relocation register is 1200, then the logical address is mapped to 1456 (256 + 1200).

Another mechanism (and the most commonly used one) is paging. While the above method requires the physical address space of a process to be contiguous, paging allows a process’s address space to be noncontiguous by dividing it into fixed-size blocks called pages. This approach enables each page of the process’s virtual address space to be independently mapped to any available frame in physical memory. In order to implement paging, every address generated by the CPU is divided into two parts, a page number and page offset.

The page size is determined by the hardware and is a power of 2 (generally between 4KB and 1GB). If the size of the logical address space is 2m and the page size is 2n bytes, then m − n bits of the logical address are used to access a specific page number and the remaining n bits of the logical address are used as page offset, pointing to a specific location within the page.

The page number is used by the MMU as an index to access the page table. The page table contains the base address of each frame in physical memory and the offset is the location within the frame that being referenced. For example, if the logical address space consists of 16 bits and 2 the page size is 4KB, then the m = 16 and n = 12. Then, the first [m − n = 4] bits will be used as page number and the remaining n(12) bits will be used as page offset. So, for this example there will be 24or16 pages.

The MMU follows the steps listed below to translate the logical address space to a physical address.

1. Extract the page number and use it as index into the page table
2. Extract the corresponding page number from the page table
3. Replace the page number in the logical address with the frame number

## Procedures

The project consists of the following procedures:

- `(binary_to_decimal binary)`: Converts a binary number to a decimal number.

- `(relocator args limit base)`: Returns the corresponding physical addresses for a list of logical addresses in binary format, given in the list args.

- `(divide_address_space num page_size)`: Returns a list consisting of the page number and page offset by splitting a logical address according to the given page_size in KB.

- `(page args page_table page_size)`: Returns the list of physical addresses of the given args with using page table and page_size in KB.

- `(find_sin value num)`: Returns the sine of an angle given in value by using the Taylor series expansion, up to a predefined number num.

- `(myhash arg table_size)`: Returns the hash value of a given binary number. The procedure first finds the decimal value of the given arg. Then, it calculates the sin of this decimal number using the first n terms of the Taylor series, where n is equal to (number mod 5) + 1. Finally, the procedure sums the first ten digits after the decimal point and takes the modulus of table size of the result.

- `(hashed_page arg table_size page_table page_size)`: Returns the physical address for a given logical address arg by using a hashed page table. A hashed page table first computes the hash value of the page number. Then, it compares this page number with the heads of the lists at the corresponding hash table index. If there a match is found, the tail of the list(frame number) is concatenated with the page offset to generate physical address.

- `(split_addresses args size)`: Given a stream of logical addresses args and the size of the logical address space size, this procedure returns a list of logical addresses.

- `(map_addresses args table_size page_table page_size address_space_size)`: Returns a list of physical addresses for a given stream of logical addresses by using a hashed page table.

## Testing

To test the project you can use Dr.Racket IDE. You can run the project by loading the file and clicking the run button. Then in the terminal you can call the functions with the desired parameters.

For example:

```racket
(find_sin 45 5)
```

This should return `0.7071067829368671`.
